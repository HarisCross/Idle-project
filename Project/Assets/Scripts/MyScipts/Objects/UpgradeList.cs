using UnityEngine;

public class UpgradeList : MonoBehaviour
{
    /// <summary>
    /// storage upgrades
    /// </summary>
    public int conn_StorageLimitCurr = 1;//current level of upgrade, base amount to inc storage amount by

    private int conn_StorageLimitMax = 5;
    private int conn_StorageLimitBaseMod = 75; //amount to increase by per upgrade level
    private int conn_StorageLimitUpgradeCost = 50; //cost to upgrade, times by curr level to get amount
    public int conn_StorageLimitIncreaseAmount = 75;

    //////public float conn_TransferLimitCurr = 1;//1-10, trasnfer limit of connector, use base amount ot inc amount allowed per trasnfer
    //////private float conn_TransferLimitMax = 10;
    //////private float conn_TransferLimitBaseMod = 25;
    //////private float conn_TransferLimitUpgradeCost = 100;
    //////public float conn_TransferLimitIncreaseAmount = 25;

    //////public int conn_MaxConnCountCurr = 0;//1-50, max amount of connectors allowed on the map itself
    //////private int conn_MaxConnCountMax = 50;
    //////private int conn_MaxConnCountUpgradeCost = 50;

    /// <summary>
    /// side upgrades
    /// </summary>
    public int side_StorageLimitCurr = 1;//current level of upgrade

    private int side_StorageLimitMax = 5;
    private int side_StorageLimitBaseMod = 75; //amount to increase by per upgrade level
    private int side_StorageLimitUpgradeCost = 50; //cost to upgrade, times by curr level to get amount
    public int side_StorageLimitIncreaseAmount = 75;

    //////public float side_TransferLimitCurr = 1;//transfer amount increase from levels, base increase jsut add to trasnfer amount
    //////private float side_TransferLimitMax = 10;
    //////private float side_TransferLimitBaseMod =15;
    //////private float side_TransferLimitUpgradeCost = 75;
    //////public float side_TransferLimitIncreaseAmount = 15;

    //////public float side_IncomeModCurr = 1;//min lv
    //////private float side_IncomeModMax = 25;//max lv
    //////private float side_IncomeModAmount = 1.05f;//amount to times by level to get modifier, times income by this then round to avoid annoying numbers
    //////private float side_IncomeModUpgradeCost = 25f;//cost per upgrade
    //////private float side_IncomeModIncreaseAmount = 1.05f;

    /// <summary>
    /// box upgrades
    /// </summary>

    public int box_StorageLimitCurr = 1;//current level of upgrade
    private int box_StorageLimitMax = 5;
    private int box_StorageLimitBaseMod = 75; //amount to increase by per upgrade level
    private int box_StorageLimitUpgradeCost = 50; //cost to upgrade, times by curr level to get amount
    private int box_StorageLimitIncreaseAmount = 75;

    /// <summary>
    /// feed grnerator upgrdes
    /// </summary>

    public int gen_StorageLimitCurr = 1;//current level of upgrade
    private int gen_StorageLimitMax = 5;
    private int gen_StorageLimitBaseMod = 75; //amount to increase by per upgrade level, applies full tom money stored and half to feed stored
    private int gen_StorageLimitUpgradeCost = 50; //cost to upgrade, times by curr level to get amount
    private int gen_StorageLimitIncreaseAmount = 75;

    //////public float gen_TransferLimitCurr = 1;//transfer amount increase from levels, base increase jsut add to trasnfer amount
    //////private float gen_TransferLimitMax = 10;
    //////private float gen_TransferLimitBaseMod = 15;
    //////private float gen_TransferLimitUpgradeCost = 75;
    //////private float gen_TransferLimitIncreaseAmount = 15;

    //////public float gen_GenModCurr = 1;//min lv
    //////private float gen_GenModMax = 25;//max lv
    //////private float gen_GenModAmount = 1.05f;//amount to times by level to get modifier, times feed generated by this then round to avoid annoying numbers
    //////private float gen_GenModUpgradeCost = 25f;//cost per upgrade
    //////private float gen_GenModIncreaseAmount = 1.05f;

    // Use this for initialization
    private void Start()
    {
    }

    // Update is called once per frame
    private void Update()
    {
    }

    //public int GetConnStorageLimit()//return amount to inc storage by, t be used by each conn to inc its storage
    //{
    //    return (conn_StorageLimitBaseMod * conn_StorageLimitCurr);
    //}

    //public int GetConnStorageLimitCost()//return the cost to upgrade, to check the cost of upgrade
    //{
    //    return (conn_StorageLimitUpgradeCost * conn_StorageLimitCurr);
    //}

    //public bool GetConnStorageUpgradePossible()//returns true if upgrade is possible
    //{
    //    if (conn_StorageLimitCurr < conn_StorageLimitMax)
    //    {
    //        return true;
    //    }
    //    else
    //    {
    //        return false;
    //    }
    //}

    public void GetVarUpdateStorageLimit(string var)//uses string passed to return the number to incresae each types storage amount by
    {
        switch (var)
        {
            case "conn":

                conn_StorageLimitIncreaseAmount = (conn_StorageLimitBaseMod * conn_StorageLimitCurr);

                return;

            case "side":

                side_StorageLimitIncreaseAmount = (side_StorageLimitBaseMod * side_StorageLimitCurr);
                return;

            case "box":
                box_StorageLimitIncreaseAmount = (box_StorageLimitBaseMod * box_StorageLimitCurr);

                return;

            case "gen":

                gen_StorageLimitIncreaseAmount = (gen_StorageLimitBaseMod * gen_StorageLimitCurr);
                return;

            default: print("getvarstoragfelimit got passed bad value"); break;
        }
    }

    public int GetVarStorageLimitUpgradeCost(string var)//uses string passed to return the cost of an upgrade
    {
        switch (var)
        {
            case "conn":
                return (conn_StorageLimitUpgradeCost * conn_StorageLimitCurr);
            //break;
            case "side":
                return (side_StorageLimitUpgradeCost * side_StorageLimitCurr);

            case "box":
                return (box_StorageLimitUpgradeCost * box_StorageLimitCurr);

            case "gen":
                return (gen_StorageLimitUpgradeCost * gen_StorageLimitCurr);

            default: print("getvarstoragfelimitCost got passed bad value"); break;
        }

        return 999999;
    }

    public bool GetVarStorageUpgradePoss(string var)//uses string passed to return bool if the upgrade is possible
    {
        switch (var)
        {
            case "conn":
                if (conn_StorageLimitCurr < conn_StorageLimitMax) return true;
                break;

            case "side":
                if (side_StorageLimitCurr < side_StorageLimitMax) return true;
                break;

            case "box":
                if (box_StorageLimitCurr < box_StorageLimitMax) return true;
                break;

            case "gen":
                if (gen_StorageLimitCurr < gen_StorageLimitMax) return true;
                break;

            default: print("getvarupgradeposs got passed bad value"); break;
        }

        return false;
    }

    public void GetVarUpgradeStorage(string var)//uses string passed to return bool if the upgrade is possible
    {
        switch (var)
        {
            case "conn":
                //check if upgrade possible, inc current level
                if (GetVarStorageUpgradePoss("conn") == true)//if the current level is lower than max then procede
                {
                    conn_StorageLimitCurr++;
                    GetVarUpdateStorageLimit("conn");//update the storage limit
                }

                break;

            case "side":

                if (GetVarStorageUpgradePoss("side") == true)//if the current level is lower than max then procede
                {
                    side_StorageLimitCurr++;
                    GetVarUpdateStorageLimit("side");//update the storage limit
                }

                break;

            case "box":

                if (GetVarStorageUpgradePoss("box") == true)//if the current level is lower than max then procede
                {
                    box_StorageLimitCurr++;
                    GetVarUpdateStorageLimit("box");//update the storage limit
                }

                break;

            case "gen":

                if (GetVarStorageUpgradePoss("gen") == true)//if the current level is lower than max then procede
                {
                    gen_StorageLimitCurr++;
                    GetVarUpdateStorageLimit("gen");//update the storage limit
                }

                break;

            default: print("getvarupgrade got passed bad value"); break;
        }

        //  return false;
    }
}